


```c
extern int attacker_controlled();

int main()
{
    char src[128];
    src[127] = 0;
    read(0, src, 127);
    
    int len = attacker_controlled();
    char *buffer = malloc((unsigned) len);
    memcpy(buffer, src, len);

    return 0;
}
```

이 코드는 모든 32비트 플랫폼에서 완전히 안전하다.
그러나, LP64모델에서, 10번, 11번 줄은 11번 줄에서 64bit 부호 확장이 일어날떄 취약점을 드러낸다.

```asm
//gcc -m32 -march=i686
main:
    push    ebp
    mov     ebp, esp
    and     esp, -16
    sub     esp, 160

    mov     BYTE PTR [esp+151], 0

    mov     DWORD PTR [esp+8], 127
    lea     eax, [esp+24]
    mov     DWORD PTR [esp+4], eax
    mov     DWORD PTR [esp], 0
    call    read
    
    call    attacker_controlled

    mov     DWORD PTR [esp+156], eax
    mov     eax, DWORD PTR [esp+156]
    mov     DWORD PTR [esp], eax
    call    malloc

    mov     DWORD PTR [esp+152], eax
    mov     eax, DWORD PTR [esp+156]
    mov     DWORD PTR [esp+8], eax
    lea     eax, [esp+24]
    mov     DWORD PTR [esp+4], eax
    mov     eax, DWORD PTR [esp+152]
    mov     DWORD PTR [esp], eax
    call    memcpy

    mov     eax, 0
    mov     esp, ebp
    pop     ebp
    ret
```

```asm
// gcc -march=x86-64
main:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 144

    mov     BYTE PTR [rbp-17], 0

    lea     rax, [rbp-144]
    mov     edx, 127
    mov     rsi, rax
    mov     edi, 0
    mov     eax, 0
    call    read

    mov     eax, 0
    call    attacker_controlled
    mov     DWORD PTR [rbp-4], eax
    mov     eax, DWORD PTR [rbp-4]
    mov     eax, eax
    mov     rdi, rax
    call    malloc

    mov     QWORD PTR [rbp-16], rax
    mov     eax, DWORD PTR [rbp-4]
    movsx   rdx, eax
    lea     rcx, [rbp-144]
    mov     rax, QWORD PTR [rbp-16]
    mov     rsi, rcx
    mov     rdi, rax
    call    memcpy

    mov     eax, 0
    leave
    ret
```

위의 소스코드가 각각 i686, x86-64플랫폼에서 컴파일된 결과로 두 어셈블리어를 얻을 수 있었다.
위의 어셈블리 소스와는 달리, 아래의 어셈블리 소스의 25번 줄에서 movsx를 볼 수 있다.
