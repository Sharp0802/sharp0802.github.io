---
LCID: ko-kr
Layout: default
Title: Little-Endian과 포인터
Timestamps:
- 2023-10-23
Topic: [ "C", "C++", "Concepts", "Memory", "Pointer" ]
---

포인터는 항상 데이터의 첫 바이트를 가리킨다.
문자열을 생각해보면 꽤 합당하고,
암묵적으로 받아들이고 있었을 말이다.

```
| 00 | 11 | 22 | 33 |
```

4바이트 정수형 변수 A(0x00112233)가 메모리상에 다음과 같이 배치되었을때,
A를 가리키는 포인터 pA는 char*로 형변환 하였을때에,
역참조한다면 00이 출력되어야 할것만 같다.

하지만, 33이 출력된다. (대부분의 x86기반 컴퓨터에서)

4바이트 정수 0x00112233은 메모리 주소상에 다음과 같이 배치되기 때문이다.

```
| 33 | 22 | 11 | 00 |
```

이렇게 바이트의 순서가 역순 꼴을 띄고 있는 것을 Little-Endian,
그렇지 않은 것을 Big-Endian이라고 한다.

## 왜?

본몬에서는 깊이 들어가지 않고,
자료형과 주소에 관하여만 서술하겠다.

int형 0x00112233을 char형으로 형변환하기로 하자.
이때, truncation이 발생하여 0x33이 되는것이 바람직해보인다.

이때, 효율적으로 형변환을 구현하기 위해,
개발자들은 바이트열을 뒤집었다.
33221100순으로 저장된다면,
주소를 바꾸지 않아도 바로 형변환된 값을 얻을 수 있기 때문이다.

## Network-Byte-Order

이와 별개로, 네트워크에서는 모든 바이트를 순열(Big-Endian)로 저장하고,
이를 Network-Byte-Order혹은 NBO라고 부른다.

